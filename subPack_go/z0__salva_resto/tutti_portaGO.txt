package portaSubPack

	import (
		"fmt"
		"os"
		"strings"
		"strconv"
	)

// begin.go
//------------------------------

func begin() { 	
	fmt.Println("func begin"); 
	
	read_all_files() 
	if sw_stop { endBegin("1"); return }
	
	//build_and_elab_word_list()
	//if sw_stop { endBegin("2"); return }
	
	//stat_useWord();	
	//if sw_stop { endBegin("3"); return }	
	
	//if sw_rewrite_wordLemma_dict { rewrite_word_lemma_dictionary() }
	
	if sw_stop { endBegin("4"); return }	
	
	//read_wordsToLearn()	
	
	endBegin("6")
	
	//writeUnaTantumNuovoFile()
	
	//-------------------------------------------
	
	numberOfRows = len(inputTextRowSlice)
	
	//buildStatistics()
	
	mainNum := strconv.Itoa(numberOfUniqueWords) +";" + strconv.Itoa(numberOfWords) + ";" + strconv.Itoa(numberOfRows) +	
		   ";))"	
		   //";" + "level " + msgLevelStat + "))" 		

	go_exec_js_function("js_go_showReadFile", mainNum + showReadFile);  
			
	if sw_stop { 
				fmt.Println("UI is ready ( run stopped because of some error)")
	} else {
		//go_exec_js_function("js_go_ready", prevRunLanguage + ":mainpage_value=" + last_mainpage_valueString)  // +"<file>" + prevRunListFile); 
		
		go_exec_js_function("js_go_ready", prevRunLanguage )
		//log.Println("UI is ready")
		fmt.Println("UI is ready")
	}	
	fmt.Println("\nEND of begin \n") 
	fmt.Println(cyan("\nREADY"), "\n") 

	
}// end of begin	

//----------------------------------
func build_and_elab_word_list() {

	fmt.Println("\n", cyan("BUILD WORD LIST") )
	
	wordSliceAlpha    = nil 
	wordSliceFreq     = nil
	uniqueWordByFreq  = nil
	uniqueWordByAlpha = nil
	
	buildWordList() 	   	
		
	elabWordList() 
	
	
} // end of build_and_elab_word_list()
 
//------------------------------------

//--------------------------------

func getPgmArgs( key0, key1 , key2 , key3, key4 string) (string, string, bool, int, string) {  
	
	//  getPgmArgs("-html", "-input" , "-countNumLines" ,  "-maxNumLinesToWrite")	

	args1    :=  os.Args[1:]		
	
	
	var val0, val1, val2, val3, val4 string
	for a:=0; a < (len(args1)-1); a++ {
		switch args1[a] {
			case key0 :   val0 = args1[a+1]
			case key1 :   val1 = args1[a+1]
			case key2 :   val2 = args1[a+1]
			case key3 :   val3 = args1[a+1]
			case key4 :   val4 = args1[a+1]
		}
	}  
	var isCount = false;
	if strings.TrimSpace(val2) == "true" {
		isCount = true
	}
	var num=0; 
	num, err := strconv.Atoi( strings.TrimSpace(val3) )
	if err != nil {
		num=0
	}

	fmt.Println("args=", args1,  " val0=", val0, " val1=", val1, " val2=", val2 , " val3=", val3, " num=", num, " val4=", val4)   
	
	return val0, val1, isCount, num, val4
	
} // end of getPgmArgs
//-------------------------------
func read_all_files() { 
	
	read_control_file()
	if sw_stop { endBegin("1"); return }
	test_all_folder()
	if sw_stop {return}
	
	read_languageFile(  FOLDER_INPUT, FILE_inputLanguage)
	if sw_stop { return }
	//get_separablePrefix()
	
	read_lemma_file( FOLDER_I_lemma, FILE_inpLemma_word_lemma, FILE_inpLemma_lemma_word)
	if sw_stop { return }
	
	read_ParadigmaFile( FOLDER_I_paradigma, FILE_inpParadigma ) ;		
	if sw_stop { return }
	
	read_dictLang_file( FOLDER_INPUT_OUTPUT, FILE_language );	 
	if sw_stop { return }
	
	read_dictLemmaTran_file( FOLDER_IO_lastTRAN, FILE_last_updated_dict_words ) 
	if sw_stop { return }	
	
	read_dictRow_Orig_and_Tran_file( FOLDER_IO_lastTRAN,  FILE_last_updated_dict_rows)
	if sw_stop { return }	
	
	read_lastValueSets2()
	
} // end of read_all_files
//-----------------------------------

func test_all_folder() {	
	test_folder_exist( FOLDER_INPUT         ); if sw_stop { return } 	
	test_folder_exist( FOLDER_OUTPUT        ); if sw_stop { return } 	
	test_folder_exist( FOLDER_INPUT_OUTPUT  ); if sw_stop { return } 
	
	test_folder_exist( FOLDER_I_lemma )     ;  if sw_stop { return } 	
	test_folder_exist( FOLDER_I_paradigma)  ;  if sw_stop { return } 	
	test_folder_exist( FOLDER_IO_lastTRAN ) ;  if sw_stop { return } 	
	
	test_folder_exist( FOLDER_O_ARCHIVE        ) ;  if sw_stop { return } 	
	test_folder_exist( FOLDER_O_arc_TRAN_rows  ) ;  if sw_stop { return } 		
	test_folder_exist( FOLDER_O_arc_TRAN_words ) ;  if sw_stop { return } 	
	test_folder_exist( FOLDER_O_arc_TO_learn   ) ;  if sw_stop { return } 	
} // end of test_all_folders

// end begin.go
//-------------------------------------- package portaSubPack

	import (
		"fmt"
		"strings"		
		"strconv"
	)
//--------------------------------------------------------
//bind_go__passToJS_.go
//-------------------------------------------
func get_all_binds() {
		fmt.Println("func get_all_binds")
		
		
		ui.Bind("go_passToJs_html_is_ready", func( msg1 string,  js_function string) { 		
				bind_go_passToJs_html_is_ready( msg1,  js_function)  })
		
		return 
}

//-----------------------------------
		
func get_all_bindsRESTO() {		
		//--------------
		/**
		ui.Bind("go_passToJs_html_and_go_ready", func( msg1 string,  js_function string) { 	
			bind_go_passToJs_html_and_go_ready( msg1,  js_function)  })
		**/
		//--------------
		//----------------------------
		ui.Bind("go_passToJs_wordList", func( isChange bool, s_fromWord string, s_numWords string, sel_level string, 
															sel_extrRow string, sel_toBeLearned string,  js_function string) { 		
				bind_go_passToJs_wordList( isChange, getInt(s_fromWord), getInt(s_numWords), sel_level, sel_extrRow, sel_toBeLearned,  js_function)  })
		//--------------------------------------		
		ui.Bind("go_passToJs_prefixWordList", func(s_numWords string, wordPrefix string, js_function string) {
				bind_go_passToJs_prefixWordList( getInt(s_numWords), wordPrefix, js_function) } )
		//--------------------------------------		
		ui.Bind("go_passToJs_betweenWordList", func( s_maxNumWords string, fromWordPref string, js_function string) {
				bind_go_passToJs_betweenWordList( getInt(s_maxNumWords), fromWordPref, js_function) } ) 	
	 	//--------------------------------------		
		ui.Bind("go_passToJs_betweenLemmaList", func( s_maxNumLemmas string, fromLemmaPref string, js_function string) {
				bind_go_passToJs_betweenLemmaList( getInt(s_maxNumLemmas), fromLemmaPref, js_function) } ) 		 			
			
		//---------------------------------------
		ui.Bind("go_passToJs_lemmaWordList", func(lemma string, inpMaxWordLemma string, js_function string) {
				bind_go_passToJs_lemmaWordList(lemma, getInt( inpMaxWordLemma),  js_function) } ) 
		//---------------------------------------	
		ui.Bind("go_passToJs_getRowsByIxWord", func( sIxWord string, max_num_row4wordS string, js_function string) {
				bind_go_passToJs_getRowsByIxWord(  getInt(sIxWord), getInt(max_num_row4wordS), js_function) } ) 
		//-----------------------------------
		ui.Bind("go_passToJs_getRowsByIxLemma", func( sIxLemma string, max_num_row4lemmaS string, js_function string) {
				bind_go_passToJs_getRowsByIxLemma(  getInt(sIxLemma), getInt(max_num_row4lemmaS), js_function) } ) 
		//-----------------------------------
		
		ui.Bind("go_passToJs_getWordByIndex2", func( s_ixWord string, swOnlyThisWordRows bool, s_maxNumRow string,  js_function string) {
				bind_go_passToJs_getWordByIndex2(   getInt(s_ixWord), swOnlyThisWordRows,      getInt(s_maxNumRow), js_function) } ) 
		//---------------------------------------
		ui.Bind("go_passToJs_thisWordRowList", func( aWord string, s_maxNumRow string, js_function string) {				
				bind_go_passToJs_thisWordRowList( aWord, getInt(s_maxNumRow), js_function) } )
		//---------------------------------------
		ui.Bind("go_passToJs_rowList", func(  s_inpBegRow string,   s_maxNumRow string, js_function string) {	
				bind_go_passToJs_rowList(     getInt(s_inpBegRow), getInt(s_maxNumRow), js_function) } )
		//---------------------------------------
	
		ui.Bind("go_passToJs_rowWordList", func( numIdOut string, s_ixRR string, js_function string ) {
				bind_go_passToJs_rowWordList(numIdOut, getInt(s_ixRR), js_function) } ) 	
		//---------------------------------------	
		ui.Bind("go_write_lang_dictionary", func( langAndVoiceName string) {
			bind_go_write_lang_dictionary( langAndVoiceName ) } ) 
		//---------------------------------------	
		ui.Bind("go_write_word_dictionary", func( listGoWords string) {
			bind_go_write_word_dictionary( listGoWords ) } )  				
		//---------------------------------------			
		ui.Bind("go_write_row_dictionary", func( listGoRows string) {
			bind_go_write_row_dictionary( listGoRows ) } )  
		//---------------------
		ui.Bind("go_passToJs_word_known", func( s_ixWord string,  s_yesNo string,  s_knowCtr string, js_function string) {
			bind_go_passToJs_word_known(       getInt(s_ixWord), getInt(s_yesNo), getInt(s_knowCtr), js_function)  } )  
			
		//----------------------------------------------------------------
		/**
		ui.Bind("go_passToJs_read_wordsToLearn", func( js_function string) {
			bind_go_passToJs_read_wordsToLearn(js_function)  } )  
		**/
		//----------------------------------------------------------------
		ui.Bind("go_passToJs_write_WordsToLearn", func( js_function string) {
			bind_go_passToJs_write_WordsToLearn(js_function)  } )  	
			
		//-----------------------------------------
		/***
		ui.Bind("go_passToJs_updateRowGroup", func( s_index string,  s_inpBegRow string,  s_inpNumRow string,  js_function string) {	
			bind_go_passToJs_updateRowGroup(       getInt(s_index), getInt(s_inpBegRow), getInt(s_inpNumRow),  js_function)   } ) 
		**/
		//-------------------------------------------------------------------
		
		ui.Bind("go_passToJs_getIxRowFromGroup", func( s_rowGrIndex string,  s_html_rowGroup_beginNum string, s_html_rowGroup_numRows string, js_function string) {		
			bind_go_passToJs_getIxRowFromGroup( getInt(s_rowGrIndex),  getInt( s_html_rowGroup_beginNum), getInt( s_html_rowGroup_numRows),  js_function)  } ) 
		
		//----------------------------------------------------------------
}  
//---------------------------------------------
func bind_go_passToJs_html_is_ready( msg1 string,  js_function string) {
	fmt.Println("\n", "go func bind_go_passToJs_html_is_ready () " , "\n\t msg from html: ", msg1 )  
	
	fmt.Println("XXXXXXXXXX   ", green("html has been loaded"), "   XXXXXXXXXXXX")
	
	begin() 
	
	fmt.Println( green( "\n\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n" + 
		"xxxxxxxxxxxxxx you can use the tool xxxxxxxxxxxxxxxxxx\n"  + 
		"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\n"  ) ) 
		
	//prova_js_function_treValori();
	
	//go_exec_js_function( js_function, msg1); 	
	
} // end of bind_go_passToJs_html_is_ready
 
//---------------------------------------------
/**
func bind_go_passToJs_html_and_go_ready( msg1 string,  js_function string) {
	fmt.Println("\n", "go func  bind_go_passToJs_html_and_go_ready() " , "\n\t msg from html: ", msg1 )  
	
	fmt.Println("XXXXXXXXXX   PRONTO  XXXXXXXXXXXX")
	
	begin() 
	
} // end of bind_go_passToJs_html_and_go_ready
***/
//-------------------------------------------------------- 

//---------------------------		

func getInt(x string) int {	
	y1, e1 := strconv.Atoi( x ) 
	if e1 == nil { 
		return y1
	} 
	y2, e2 := strconv.Atoi(  "0"+strings.TrimSpace(x)  ) 
	if e2 == nil {
		return y2
	} else {
		fmt.Println("error in getInt(",x,") ", e2) 
	}
	return 0
}

//-------------------------------------
func showErrMsg(errorMSG0 string, msg1 string, func1 string) {
	errorMSG = strings.ReplaceAll( errorMSG0, "\n"," ") 
	fmt.Println(msg1, " func ", func1)
	go_exec_js_function( "js_go_setError", errorMSG ); 	
}
//--------------------------------
func showErrMsg2(errorMSG0 string, msg1 string) {
	errorMSG = strings.ReplaceAll( errorMSG0, "\n"," ") 
	fmt.Println(msg1)
	go_exec_js_function( "js_go_setError", errorMSG ); 	
}
//------------------------------
func showInfoRead( fileName string, startStop string) {
		
	msg1_Js := "file " + fileName + " " + startStop 
 	msg1:=`<br>file &nbsp;&nbsp;<span style="color:blue;" >` + fileName + `</span>`	+ 				
				`<br><span style="font-size:0.7em;color:black;">`	+ startStop	+ `</span>` 		
				
	showErrMsg2(msg1, msg1_Js)	
}
//------------------------------------------------
func isNumber(s string) bool {
    for _, v := range s {
        if v < '0' || v > '9' {
            return false
        }
    }
    return true
}


//end of bind_go__passToJS_.go

//-----------------------------------------------------------package portaSubPack

/**
import (  
    "strings"
)
**/
//--------------------------------------
// color.go
//---------------------------------------
/**         ***  COLORS: got from https // www.dolthub.com/blog/2024-02-23-colors-in-golang/ ***
    var Reset   = "\033[0m" 
	var Red     = "\033[31m" 
	var Green   = "\033[32m" 
	var Yellow  = "\033[33m" 
	var Blue    = "\033[34m" 
	var Magenta = "\033[35m" 
	var Cyan    = "\033[36m" 
	var Gray    = "\033[37m" 
	var White   = "\033[97m"
**/

func red(     str1 string) string { return "\033[31m" + str1 +  "\033[0m" }
func green(   str1 string) string { return "\033[32m" + str1 +  "\033[0m" }
func yellow(  str1 string) string { return "\033[33m" + str1 +  "\033[0m" }
//func blue(  str1 string) string { return "\033[34m" + str1 +  "\033[0m" }
func magenta( str1 string) string { return "\033[35m" + str1 +  "\033[0m" }
func cyan(    str1 string) string { return "\033[36m" + str1 +  "\033[0m" }
//func gray(  str1 string) string { return "\033[37m" + str1 +  "\033[0m" }
//func white( str1 string) string { return "\033[97m" + str1 +  "\033[0m" }

//---------------------------------------------------------------------------------package portaSubPack
//--------------------------
//declare.go
//-----------------------------------------
const wSep = "§";                         // used to separe word in a list 
const endOfLine = ";;\n"
var lemma_para_list = make([]paraStruct, 0, 0 )   	
var lemmaNotFoundList = make([]string,0,100)
//----------------------
var level_other = "Oth"
var list_level_str = " " + level_other + " A0 A1 A2 B1 B2 C1 C2 "
var list_level          = make([]string,0, 0) 
var only_level_numWords = make([]int,   0, 0)  
var perc_level          = make([]int,   0, 0)  
//-------------------------------------------
var separRow   = "[\r\n.;:?!]";
//var separRowFalse = "[\r\n]";
var separWord = "["     +
			"\r\n.;?!" + 
			"\t"       +
			" "        + 
			",:"       +
            "|"        +
			"¿"        +	
			"°"        + 
			"¡"        + 
			"\\"       + 
			"_"        +
			"\\+"      +
			"\\*"      +
			"()<>"     + 
			"\\]\\["   +
			"`{}«»‘’‚‛“””„‟" +		
			"\""       + 
			"'"        + 	
			"\\/"      +  
			wSep       + 
			"]" ; 	
//-------------------------------------
var fseq = "z§" ; 
var lenFseq = len(fseq) 
//--------------------------
//var apiceInverso = `40`  //  in windows:  tasto Alt + 96 (tastierino numerico)
var lastPerc=0; 
var prevPerc = -1; 
var sw_list_Word_if_in_ExtrRow = false    // se true, lista soltanto le parole che si trovano su righe estratte  
//-----------------
//---------------------------------------------

var last_written_dict_rowFile string = "";         //  filename of the last written dictionary row file   

//------------------------------
const BASE_rowGrNum = 100000;  // centomila,  1 e 5 zeri


var sw_rewrite_wordLemma_dict bool = true

//---
var sw_write_numbered_text  bool = false
var fname_out_numbered_text string = ""  
var fPrefix_out_numbered_text string = ""  
var outNumberBegin       int  = 0    //   write numbered text beginning with this number    
//---
var sw_read_numbered_text   bool = false
var fname_inp_numbered_text string = ""  
var fPrefix_inp_numbered_text string = ""  
//-----------------------

//var outWordLemmaDict_file = "newWordLemmaDict.txt";
//var outLemmaTranDict_file = "newLemmaTranDict.txt"
//var outLemmaNotFound      = "newLemmaNotFound.txt"
//var words_to_learn_file   = "ixWordsToLearn.txt"    

//var outRowTran_file  = "newRowDict.txt"
var sw_ignore_newLine bool = false
var sw_nl_only        bool = false
//------------------------------------

const LAST_WORD = "\xff\xff\xff"

//------
var parameter_path_html string  = "WBF_html_jsw"
//------------------



var separRowList = make([]string,0,0)		


var msgLevelStat = "" 

var sw_PRINT_TIME bool = false;                 // in caso di durata abnorme, usa true per vedere dove impiega più tempo

var wordSliceAlpha = make([]wordStruct, 0, 0)  
var wordSliceFreq  = make([]wordStruct, 0, 0)  


var uniqueWordByFreq  []wordIxStruct;   // elenco delle parole in ordine di frequenza
var uniqueWordByAlpha []wordIxStruct;   // elenco delle parole in ordine alphabetico


var dictLemmaTran []lemmaTranStruct ;  // dictionary lemma translation  


var wordStatistic_tx =  make( []statStruct, 101, 101);	
var inputTextRowSlice       []rowStruct;
var isUsedArray    []bool

//var rowLineIxList     []rowIxStruct

var lista_gruppiSelectRow  = make([]  rowGroupStruct, 0, 100)  

var countNumLines  bool = false 
var maxNumLinesToWrite = 0
var lemmaFormat   = "word lemma"
var sw_lemma_word = false 

//var rowArrayByFreq []rowStruct;
//-------------------------------

var dictionaryWord = make([]wDictStruct,0,0);  
var numberOfDictLines =0;  
//var dictionaryRow  = make([]rDictStruct,0,0);  
var numberOfRowDictLines =0;  
var prevRunLanguage = ""; 
//var prevRunListFile = "" 
//-----------

var numberOfRows  = 0; 
var numberOfWords = 0; 
var numberERRORS=0
var numberOfUniqueWords = 0; 
var showReadFile string = ""
//--------------------------------------------------------
//var scrX, scrY int = getScreenXY();


var sw_begin_ended = false     
var sw_HTML_ready  = false     
//--------------------------------

//---------------------------------

var last_rG_ixSelGrOption   	int = 0 
var last_rG_group           	string = ""  
var last_rG_firstIxRowOfGr  	int = 0     
var last_rG_lastIxRowOfGr   	int = 0       
var	last_ixRowBeg           	int = 0	 
var	last_ixRowEnd           	int = 0	

var last_html_rowGroup_index_gr int = 0
var last_html_rowGroup_beginNum int = 0 
var last_html_rowGroup_numRows  int = 0
var last_word_fromWord          int = 0 
var last_word_numWords          int = 0
var last_sel_extrRow            string = "" 	
//--------------------------
var separPrefList = make([]separPrefStruct, 0, 200) 
//--------------------------
	
var last_run_extrRow = ""	
//---------------
// end of declare.go
//-----------------------------------------package portaSubPack


//- file_and_folder.go --------------

var	html_path         string = "WBF_html_jsw"

//--file_and_folder.go-------------
var file_inputControl string = "inputControl.txt";     // file control   ( file names and switches) 

var main_input_text_file string = ""              // input text file ( this is the real input, it is unnumbered, it's read when read_numbered_text = false)  
 
//---------------------------------
var outFile          = "outFileProva.csv" 
//--------------------------------------------

const FOLDER_I_lemma         string = "INPUT/inputLemma"

const FOLDER_INPUT          string = "INPUT"
const FOLDER_OUTPUT         string = "OUTPUT"
const FOLDER_INPUT_OUTPUT   string = "INPUT_OUTPUT"
const FOLDER_IO_lastTRAN    string = "INPUT_OUTPUT/lastTRAN"  
const FOLDER_I_paradigma    string = "INPUT/inputParadigma"
const FOLDER_O_ARCHIVE        string = "OUTPUT/archive"
const FOLDER_O_arc_TRAN_rows  string = "OUTPUT/archive/arc_TRAN_ROWS"
const FOLDER_O_arc_TRAN_words string = "OUTPUT/archive/arc_TRAN_words"
const FOLDER_O_arc_TO_learn   string = "OUTPUT/archive/arc_TO_learn"

const FOLDER_inpNumText string = "inpNumTEXT"
const FOLDER_outNumText string = "outNumTEXT"
const FOLDER_outTRAN    string = "outTRAN"

const FOLDER_dictionary string = "myDictionary"

const FILE_inputLanguage     string = "inputLanguage.txt"
const FILE_outWordLemmaDict  string = "newWordLemmaDict.txt";

// const FILE_inpLemma_word_lemma   string = "myWordLemmaFile_fmtWordLemma.txt"  

const FILE_inpLemma_word_lemma   string = "myWordLemmaFile_fmtWordLemma.txt"  
const FILE_inpLemma_lemma_word   string = "myWordLemmaFile_fmtLemmaWord.txt"  


//------------------------------------------------
const FILE_last_updated_dict_rows  string = "lastUpdated_dict_tran_rows.txt"	
const FILE_last_updated_dict_words string = "lastUpdated_dict_tran_words.txt" 
//const FILE_ outLemmaTranDict  string = "newLemmaTranDict.txt"
const FILE_outLemmaNotFound  string = "newLemmaNotFound.txt"
const FILE_words_to_learn    string = "wordsToLearn.txt"   

const FILE_last_mainpage_values2 string = "last_mainpage_values2.txt" // to transfer values between runs
const FILE_inpParadigma      string = "myParadigma.csv" ; 
const FILE_language          string = "language.txt"           // lang and voice file    
//---------------------------------------------
package portaSubPack

import (  
	"fmt"
    "strings"
	"runtime"
)
//------------------------
//go_exec_js_function.go
//----------------------------------------------------------------
func go_exec_js_function(js_function0 string, inpstr string) {
	var goFunc string 
 	pc, _, _, ok := runtime.Caller(1)
	details := runtime.FuncForPC(pc)
	if ok && details != nil {
		goFunc = strings.ReplaceAll(details.Name(), "main.","")
	} else {
		goFunc=""
	}
	js_fun        := strings.Split( (js_function0 + ",,,,") ,",") 	
	js_function   := strings.TrimSpace( js_fun[0] )
	if js_function == ""  { return }
	jsInpFunction := strings.TrimSpace( js_fun[1] )
	
	js_parm:=""
	k1:= strings.Index(js_function, "(") 
	if k1 > 0 {
		js_parm     = strings.ReplaceAll(  js_function[k1+1:], ")","")			
		js_function = strings.TrimSpace(js_function[0:k1] )
	} 
	/**
	fmt.Println("  js_function=" + js_function)
	fmt.Println("      js_parm=" + js_parm)
	fmt.Println("jsInpFunction=" + jsInpFunction)
	fmt.Println("       goFunc=" + goFunc)
	**/
	
	/*
	This function executes a javascript eval command 
	which must execute a function by passing string constant to it. 
	Should this string contain some new line, e syntax error would occur in eval the statement.
	
	To avoid this kind of error, the string argument (inpstr) of the javascript function (js_function) 
	is forced to be always enclosed in back ticks trasforming it in "template literal".  
	Just in case back ticks and dollars are in the string, they are replaced by " "   	
	*/
	inpstr = strings.ReplaceAll( inpstr, "`", " "   ); 	   	 
	inpstr = strings.ReplaceAll( inpstr, "$", "&dollar;"); 
	
	evalStr := fmt.Sprintf( "%s(`%s`,`%s`,`%s`,`%s`);",  js_function, inpstr, js_parm, "js=" + jsInpFunction, "go=" + goFunc ) ; 
	
	//fmt.Println("evalStr=" + evalStr); 
	
	ui.Eval(evalStr)
	
} // end of go_exec_js_function
//----------------------------------------------------------------

func go_exec_js_functionX(js_function string, inpstr string ) {
	/*
	This function executes a javascript eval command 
	which must execute a function by passing string constant to it. 
	Should this string contain some new line, e syntax error would occur in eval the statement.
	
	To avoid this kind of error, the string argument (inpstr) of the javascript function (js_function) 
	is forced to be always enclosed in back ticks trasforming it in "template literal".  
	Just in case back ticks and dollars are in the string, they are replaced by their html symbols.   	
	*/
	inpstr = strings.ReplaceAll( inpstr, "`", " "   ); 	  
	//inpstr = strings.ReplaceAll( inpstr, "`", "&#96;"   ); 	 
	inpstr = strings.ReplaceAll( inpstr, "$", "&dollar;"); 
	
	evalStr := fmt.Sprintf( "%s(`%s`);",  js_function,  inpstr ) ; 
	
	ui.Eval(evalStr)
	
} // end of go_exec_js_function

//--------------------------------
// end of go_exec_js_function.go
//----------------------------------------------------package portaSubPack

	import (
		"fmt"
		"os"
		"strings"		
		"github.com/zserge/lorca"	
		"github.com/lxn/win"	
	)
	
//------------------------------------------------
//html_env.go	
//--------------------------------------------------------
var scrX, scrY int = getScreenXY();


//------------------------------

var ui, err = lorca.New("", "", scrX, scrY); // crea ambiente html e javascript  // if height and width set to more then maximum (eg. 2000, 2000), it seems it works  


//---------------------
func getScreenXY() (int, int) {
	
	// use ==>  var x, y int = getScreenXY();
	
	var width  int = int(win.GetSystemMetrics(win.SM_CXSCREEN));
	var height int = int(win.GetSystemMetrics(win.SM_CYSCREEN));
	if width == 0 || height == 0 {
		//fmt.Println( "errore" )
		return 2000, 2000; 
	}	
	width  = width  - 20;  // subtraction to make room for any decorations 
	height = height - 40;  // subtraction to make room for any decorations 
	
	return width, height
}
//----------------------------------	

func begin_GO_HTML_Talk() { 	
	fmt.Println("func begin_GO_HTML_Talk"); 
	setHtmlEnv();	
}
//---------------

//------------------------------------
func setHtmlEnv() {	
	fmt.Println("func setHtmlEnv:  start load html")
    // load file html 	
	
	html_path = getCompleteHtmlPath( parameter_path_html ) 
	            
	fmt.Println("path html        = " + html_path)
	
	ui.Load("file:///" + html_path + string(os.PathSeparator) + "wordsByFrequency.html" ); 
	
	fmt.Println("\n", "func setHtmlEnv: wait for html ( javascript function js_call_go()", "\n")  
	
} // end of setHtmlEnv
//--------------------------------------------------------
//-------------------------
func getCompleteHtmlPath( path_html string) string {
	
	//curDir    := "D:/ANTONIO/K_L_M_N/LINGUAGGI/GO/_WORDS_BY_FREQUENCE/WbF_prova1_input_piccolo
	 
	curDir, err := os.Getwd()
    if err != nil {
		fmt.Println("setHtmlEnv() 3 err=", err )
        //log.Fatal(err)
    }	
				
	fmt.Println("curDir           = " + curDir ); 
	
	curDirBack  := curDir
	k1:= strings.LastIndex(curDir, "/") 
	k2:= strings.LastIndex(curDir, "\\") 
	if k2 > k1 { k1 = k2 } 
	curDirBack = curDir[0:k1] 	
	
	var newPath string = ""
	if strings.Index(path_html,":") > 0 {
		newPath = path_html
	} else if path_html[0:2] == ".." {
		newPath = curDirBack  + path_html[2:] 
	} else {
		newPath = curDir + path_html
	}
	return newPath 
} 
//------------------------
func putFileError( msg1, inpFile string) {
	err1:= `document.getElementById("id_startwait").innerHTML = '<br><br> <span style="color:red;">§msg1§</span> <span style="color:blue;">§inpFile§</span>';` ; 		
	err1 = strings.ReplaceAll( err1, "§msg1§", msg1 ); 	 
	err1 = strings.ReplaceAll( err1, "§inpFile§", inpFile); 	
	ui.Eval( err1 );	
}   

//-----------------------------------
// end of html_env.go	
//--------------------------------------------------------package portaSubPack

	import (
		"fmt"
		"os"
		"os/signal"
		"strings"	
		"runtime"	
	)
//---------------------
//myMain.go
//------------------------------------------------------
func MyMain() {

	fmt.Println("\n======================\n         My Main()  INIZIO di mainPack \n===============================\n")
	fmt.Println(  red("WordsByFrequence - wbfMain") )
	
	fmt.Println( "\ncolori:", red("rosso"), green("verde"), yellow("giallo"),  magenta("magenta"), cyan("ciano") , "\n"  )  
	
	//---------------
	val0, val1, val2, val3, val4 := getPgmArgs("-html",  "-input" , "-countNumLines" , "-maxNumLinesToWrite", "-lemmaformat")	
	//----------
	countNumLines      = val2
	maxNumLinesToWrite = val3
	lemmaFormat        = val4
	
	sw_lemma_word = (lemmaFormat == "lemma-word")
	
	if val0 != "" { parameter_path_html = strings.ReplaceAll(val0,"\\","/")  } 
	if val1 != "" { file_inputControl   = strings.ReplaceAll(val1,"\\","/")  }  		
	
	fmt.Println("\n"+ "parameter_path_html =" + parameter_path_html + "\n" +  "input = " + file_inputControl )
	fmt.Println("countNumLines       = " ,  countNumLines)
	//fmt.Println("maxNumLinesToWrite = " , maxNumLinesToWrite) 
	
	fmt.Println("lemmaformat = ", lemmaFormat, " sw_lemma_word =", sw_lemma_word)
	fmt.Println("\n----------------\n")	
	
	//-----------------------------------
	args := []string{}
	if runtime.GOOS == "linux" {
		args = append(args, "--class=Lorca")
	}
	//  err := lorca.New("", "", 480, 320, args...) moved out of main so that ui is available outside main()
	if err != nil {
		fmt.Println( red( "errore in lorca "), err )  //  //log.Fatal(err)
	}
	defer ui.Close()
	
	get_all_binds()  //  binds inside are executed asynchronously after calling from js function (html/js are ready) 
	
	begin_GO_HTML_Talk();  // this function is  executed firstily before html/js is ready  
	
	// the following in main() is executed at the end when the browser is close 
	// Wait until the interrupt signal arrives or browser window is closed
	sigc := make(chan os.Signal)
	signal.Notify(sigc, os.Interrupt)
	select {
		case <-sigc:
		case <-ui.Done():
	}
	fmt.Println("exiting") // log.Println("exiting...")
}
//-----------------------------------------
func endBegin(wh string) {
	//fmt.Println("func endBegin (", wh,")")
	if sw_stop { 
		fmt.Println("\nXXXXXXXX  error found XXXXXXXXXXXXXX\n"); 
	}	
	sw_begin_ended = true 		
}
//--------------------------------

func read_dictLang_file( path1 string, inpFile string) {
	bytesPerRow:= 10
    lineD := rowListFromFile( path1, inpFile, "scelta lingua e voce", "read_dictLang_file", bytesPerRow)  
	if sw_stop { return }
	
	lineZ := ""
	prevRunLanguage = ""	
	for z:=0; z< len(lineD); z++ { 
		lineZ = strings.TrimSpace(lineD[z]) 
		if lineZ == "" { continue }
		if lineZ[0:9] == "language=" {			
			prevRunLanguage = lineZ[9:] 			
		}
	}	
}// end of read_dictLang_file		

//-------------------------------------

func check(e error) {
    if e != nil {
        panic(e)
    }
}

//--------------------------------
//end of myMain.go
//------------------------------------------------------
package portaSubPack

import (  
	"fmt"
    "strings"
    "sort"
)
//-----------------------------------------------------
//read_word_lemma.go
//-----------------------------------------------------------

const LAST_WORD_FREQ = 999999999 
//---------------------
var righe      =  []string{} 
//------------
//------------
var newWordLemmaPair    [] wordLemmaPairStruct // all word-lemma pair 
var lemma_word_ix []lemmaWordStruct  

var lemmaSlice       [] lemmaStruct         // lemma , translation 

var wordLemmaPair    [] wordLemmaPairStruct // all word-lemma pair  
var numLemmaDict int =0 
var sw_stop bool = false
var errorMSG = ""; 
//----------------------------------------

func read_lemma_file( path1 string, inpLemmaFile_wordLemma, inpLemmaFile_lemmaWord string) {
	
	//showInfoRead( inpLemmaFile, " inizio lettura " )
	
	bytesPerRow:=10
	numLemmaDict=0; 
	
	var wordLemma1 wordLemmaPairStruct 
	//------
	file1_bytes := getFileByteSize(path1, inpLemmaFile_wordLemma)
	file2_bytes := getFileByteSize(path1, inpLemmaFile_lemmaWord)
	fmt.Println("file ", inpLemmaFile_wordLemma, "  ", file1_bytes , " bytes") 
	fmt.Println("file ", inpLemmaFile_lemmaWord, "  ", file2_bytes , " bytes") 
	numEleMax:= int(  (file1_bytes + file2_bytes) / bytesPerRow ); 
	if numEleMax < 10 {numEleMax=10}
	//----------------
    lineS:= rowListFromFile( path1, inpLemmaFile_wordLemma, "1assoc. word-lemma", "read_lemma_file", bytesPerRow)  		
	
	var wordLemmaPairTMP = make( []wordLemmaPairStruct, 0, numEleMax)
	
	if (sw_stop == false) {	
		// read word lemma
		for z:=0; z< len(lineS); z++ { 
			lineZ0 := strings.TrimSpace(lineS[z])   //  format:     word   lemma		
			if lineZ0 == "" {continue}
			lineZ := strings.ReplaceAll( lineZ0, "\t" , " ")			
			
			cols:= strings.Fields( strings.ToLower( lineZ ) )   // Fields   split using whitespace,  treats consecutive whitespace characters as a single separator		
			if len(cols) < 2 { continue } 
			wordLemma1.lWord2   = stdCode( cols[0] ) 		
			wordLemma1.lLemma   = stdCode( cols[1] )	
			
			if len(wordLemma1.lLemma) < 1 { continue;  } 
			if ((wordLemma1.lLemma == "-") || (wordLemma1.lLemma[0:1] < "A")) { continue;  }   // ignore number  
			
			wordLemma1.lWordSeq = seqCode( wordLemma1.lWord2)
			wordLemma1.lIxLemma = -1	
			
			wordLemmaPairTMP = append(wordLemmaPairTMP, wordLemma1 ) 
			numLemmaDict++		
		}
		fmt.Println(" read ", len(lineS), " input lemma: format word-lemma")
	}
	
	//----------------
    lineS = rowListFromFile( path1, inpLemmaFile_lemmaWord, "2assoc. lemma-word", "read_lemma_file", bytesPerRow)  		
	
	if (sw_stop == false) {	
		// read word lemma
		for z:=0; z< len(lineS); z++ { 
			lineZ0 := strings.TrimSpace(lineS[z])   //  format:     word   lemma		
			if lineZ0 == "" {continue}
			lineZ := strings.ReplaceAll( lineZ0, "\t" , " ")			
			
			cols:= strings.Fields( strings.ToLower( lineZ ) )   // Fields   split using whitespace,  treats consecutive whitespace characters as a single separator		
			if len(cols) < 2 { continue } 	
			wordLemma1.lWord2   = stdCode( cols[0] ) 		
			wordLemma1.lLemma   = stdCode( cols[1] )	
			
			if len(wordLemma1.lLemma) < 1 { continue;  } 
			if ((wordLemma1.lLemma == "-") || (wordLemma1.lLemma[0:1] < "A")) { continue;  } 
			
			wordLemma1.lWordSeq = seqCode( wordLemma1.lWord2)
			wordLemma1.lIxLemma = -1
				
			wordLemmaPairTMP = append(wordLemmaPairTMP, wordLemma1 ) 
			numLemmaDict++		
		}
		fmt.Println(" read ", len(lineS), " input lemma: format lemma-word")
	}
	
	//-----------------------------------
	lineS = nil
	//---------------------------------------	
	//-----		
	fmt.Println( "lette " , numLemmaDict ,  " coppie word-lemma", "\n")
	//-----	
	// sort x lemma, word
	sort.Slice(wordLemmaPairTMP, func(i, j int) bool {
			if (wordLemmaPairTMP[i].lLemma != wordLemmaPairTMP[j].lLemma) {
				return wordLemmaPairTMP[i].lLemma < wordLemmaPairTMP[j].lLemma
			} else {
					return wordLemmaPairTMP[i].lWord2 < wordLemmaPairTMP[j].lWord2
			}
		} )	 
	/***
	sort.Slice(wordLemmaPairTMP, func(i, j int) bool {
			if (wordLemmaPairTMP[i].lLemma != wordLemmaPairTMP[j].lLemma) {
				return wordLemmaPairTMP[i].lLemma < wordLemmaPairTMP[j].lLemma
			} else {
				if wordLemmaPairTMP[i].lype != wordLemmaPairTMP[j].lype {
					return wordLemmaPairTMP[i].lype < wordLemmaPairTMP[j].lype 
				} else {
					return wordLemmaPairTMP[i].lWord2 < wordLemmaPairTMP[j].lWord2
				}
			}
		} )	 	
		***/
	//-------------------------------------
	
	wordLemmaPair = make( []wordLemmaPairStruct, 0, len(wordLemmaPairTMP)	)
	
	buildListLemmaSlice(wordLemmaPairTMP)
	
	
	//-------------------------------------
	fmt.Println( green("lemmaSlice"), "  composto da ", len(lemmaSlice) , " elementi")    
	
	//-----------------------------
	/**
	seq:=""; swerr:=false
	for  _, lem := range lemmaSlice {
		if lem.leLemma < seq {
			fmt.Println(red("ERRORE lemmaSlice fuori sequenza "), " pre=", seq, "   new=", lem.leLemma )
			//swerr = true
			break;
		}
		seq = lem.leLemma
	}
	
	if swerr == false { fmt.Println( green("lemmaSlice IN SEQUENZA")) 	}
	**/
	//---------------------------------
	
	//--------------------------------
	// sort x word , lemma 
	sort.Slice(wordLemmaPair, func(i, j int) bool {
			if (wordLemmaPair[i].lWordSeq != wordLemmaPair[j].lWordSeq) {
				return wordLemmaPair[i].lWordSeq < wordLemmaPair[j].lWordSeq
			} else {
				if (wordLemmaPair[i].lWord2 != wordLemmaPair[j].lWord2) {
					return wordLemmaPair[i].lWord2 < wordLemmaPair[j].lWord2 
				} else {
					return wordLemmaPair[i].lLemma < wordLemmaPair[j].lLemma
				}
			}
		} )	 
	//------------------------	
	
	check_wordLemma_sameCode()
	
	
	
	//-------------------------------
} // end of  read_lemma_file

//-------------------------------------------

func check_wordLemma_sameCode() {
	fmt.Println( green("check_wordLemma_sameCode") , "()"  )
	// check same words  written in diffent way (eg. caesar   and  "cäsar")
	pre_wordCod := ""
	pre_word2   := ""	
	//pre_lemma   := ""
	pre_z := -1
	
	for z, wordPair := range wordLemmaPair {	
			//if ((  wordPair.lWord2 == "cäsar") || (wordPair.lWord2 == "caesar") || (wordPair.lWord2 == "casar") ) { fmt.Println(" check 222 Lemma ", z,  " wordPair=" , wordPair) }
	
		if (wordPair.lWordSeq != pre_wordCod) {
			pre_wordCod = wordPair.lWordSeq 
			pre_word2   = wordPair.lWord2 
			//pre_lemma   = wordPair.lLemma 
			pre_z = z
			continue
		}
		if (wordLemmaPair[z].lWord2 == pre_word2) {
			continue
		}
		//--------
		fmt.Println( green("check_wordLemma_sameCode") )
		for x:= pre_z; x<= z; x++ {
			fmt.Println("\t", " wordLemmaPair[",x,"] = ", wordLemmaPair[x] )   
		} 
		
	}	
	
} // end of check_wordLemma_sameCode

//-----------------------------------------------------
//end of read_word_lemma.go
//-----------------------------------------------------------

package portaSubPack

//-------------------------------
//structure.go
//---------------

type separPrefStruct struct {
	sLenPref  int 
	sPrefix   string 
	sPrefTran string 	
}
//---
type lemmaStruct struct {
	leLemma    string        // ls_lemma_einstellen einstellen
	
	leNumWords int 
	leFromIxLW  int 
	leToIxLW    int  
	leTran      string 
	leLevel     string  
	lePara      string  
	leExample   string  
	ls_lemma_ix_stellen  int	
	ls_lemma_stellen     string
	ls_pref_ein          string
	ls_pref_tran         string 
	ls_lemma_einStellenList []int 
} 
//-------------------------------

type wordLemmaPairStruct struct {
	lWordSeq string 
	lWord2   string 
	lLemma   string
	lIxLemma int
	lIx_einStellenList []int 
} 
//---

//---------------
type lemmaWordStruct struct {
	lw_lemmaSeq string 	
	lw_lemma2   string 	
	lw_prefix   string
	lw_word     string 
	lw_ixLemma    int
	lw_ixWordUnFr int
	lw_origLemma string
}

type rowStruct struct {
	rIdRow       string
	rixGroup     int      // indice del gruppo 
	rixBaseGroup int      // posizione del row nel gruppo ( si inzia dal num.1 )  
    rRow1        string
	rNfile1      int  
	rSwExtra     bool 
    rNumWords    int       // number of words in the row 
	rListIxUnF   []int     // for each word in the row, index of the word in the uniqueWordByFreq  
	rListFreq    []int     // for each word in the row, how many times the woird is used in all the text    
	rTran1       string 
}

type rowGroupStruct struct {
	rG_ixSelGrOption  int 
	rG_group          string 
	rG_firstIxRowOfGr int 
	rG_lastIxRowOfGr  int	
} 

type rowIxStruct struct {
	ixR_id        string  // group + "_" + string(100000 + num)
	ixR_id_gr     string
	ixR_id_num    int  
    ixR_ix        int	
	ixR_ix_last   int 
}
const SEL_EXTR_ROW    = 1; 
const SEL_NO_EXTR_ROW = 2; 

//--
type wordStruct struct {       // a word is repeated several time one for each row containing it  
	wWordSeq  string
    wWord2    string
	wIxUniq   int               // index of uniqueWordByFreq      
	wNfile    int 
	wSwSelRowG int
	wSwSelRowR int
    wIxRow    int       
	wIxPosRow int 
	wTotRow   int              // number of rows 
	wTotExtrRow int            // number of extracted rows 
	wTotMinRow int
	wTotWrdRow int 
}
//--
type wordIxStruct struct {
	uWordSeq    string	
    uWord2      string	
	uIxUnW      int            // index of this word in the uniqueWordByFreq	
	uIxUnW_al   int            // index of this word in the uniqueWordByAlpha 	
	uTotRow     int 
	uTotExtrRow int
    uIxWordFreq int            // index of this word in the wordSliceFreq	
	uSwSelRowG  int
	uSwSelRowR   int  
	uKnow_yes_ctr int 
	uKnow_no_ctr  int         // a value > 0  means that this is a word that I don't know, ie. it's to be learned   
	uIxLemmaL  []int  
	uLemmaL    []string       // list of lemma 
	//uTranL     []string       // list of translation    
	uLevel     []string  
	uPara      []string  
	uExample   []string  
}	

//---
type wDictStruct struct {
	dWord  		string 
	dIxWuFreq 	int 
	dLemmaL     []string 
	dTranL      []string 	
} 

//---------------
type statStruct struct {
	uniqueWords  int 
	uniquePerc   int 
	totWords  int
	totPerc   int 
}
//--------------------------
var lastNumDict = 0;   
type lemmaTranStruct struct {
	dL_lemmaSeq  string 
	dL_lemma2    string 
	dL_numDict   int	
	dL_tran      string         //
	
} 
//---------------
type paraStruct struct {
	p_lemma    string	
	p_ixLemma  int 
	p_level    string
	p_para     string
	p_example  string 
}	
//--------------------------------
//end of structure.go
//---------------
package portaSubPack

import (  
	"fmt"
	"os"	
    "bufio"	
	"sort"
	"time"
	//"strings"
)
//--------------------------------
//write_and_rewrite.go
//----------------------------------
func rewrite_word_lemma_dictionary() {	
	
	//----------------------------------------------------
	sort.Slice(newWordLemmaPair, func(i, j int) bool {
			if (newWordLemmaPair[i].lWordSeq != newWordLemmaPair[j].lWordSeq) {
				return newWordLemmaPair[i].lWordSeq < newWordLemmaPair[j].lWordSeq
			} else {
				if (newWordLemmaPair[i].lWord2 != newWordLemmaPair[j].lWord2) {
					return newWordLemmaPair[i].lWord2 < newWordLemmaPair[j].lWord2 
				} else {
					return newWordLemmaPair[i].lLemma < newWordLemmaPair[j].lLemma
				}
			}
		} )		 	
	//------------			
	outFile := FOLDER_OUTPUT +  string(os.PathSeparator) + FILE_outWordLemmaDict ;		
	
	lines:= make([]string, 0, 10+len(newWordLemmaPair) )

	lines = append(lines,  "__" + outFile + "\n" + "_word _lemma ")
	
 	for z:=0; z < len( newWordLemmaPair); z++ {
		//lines = append(lines,  newWordLemmaPair[z].lWord2 + "|" + newWordLemmaPair[z].lLemma) 
		lines = append(lines,  newWordLemmaPair[z].lWord2 + " " + newWordLemmaPair[z].lLemma) 
	}  	
	
    writeList( outFile, lines )
	
	
} // end of rewrite_word_lemma_dictionary

//--------------------------------

func rewrite_LemmaTranDict_file() {

	//fmt.Println( "GO ", green("rewrite_LemmaTranDict_file" ))
	
	//outFile := FOLDER_IO_lastTRAN +  string(os.PathSeparator) + FILE_ outLemmaTranDict;
	
	outFile := FOLDER_IO_lastTRAN  +  string(os.PathSeparator) + FILE_last_updated_dict_words 

	pkey := ""; key := ""
	
	lines:= make([]string, 0, 10+len(dictLemmaTran) )
	lines = append(lines,  "__" + outFile + "\n" + "_lemma	_traduzione")
	
	for z:=0; z < len(dictLemmaTran); z++ {
	
		pkey=key
		
		
		
		key = dictLemmaTran[z].dL_lemma2 + "|"  + dictLemmaTran[z].dL_tran  		////cigna1_3
		
		//if strings.Index(key,"eindhoven")>=0 { fmt.Println("rewrite_LemmaTranDict_file ",  dictLemmaTran[z],  " key=",key, " pkey=", pkey) }
		
		if pkey == key { continue}
		
		lines = append(lines, key ) 
	}
	writeList( outFile, lines )
	//--------------------

	currentTime := time.Now()		
	outF1 		:= FOLDER_O_arc_TRAN_words +  string(os.PathSeparator) + "dictL"  		
	outFile2 := outF1 + currentTime.Format("20060102150405") + ".txt"
	
	writeList( outFile2, lines )
	
	
} // end of rewrite_LemmaTranDict_file

//----------------------
func writeList( fileName string, lines []string)  {
	// create file
    f, err := os.Create( fileName )
    if err != nil {
        fmt.Println( red("error")," in writeList file=", fileName,"\n\t" , err ) //  log.Fatal(err)
    }
    // remember to close the file
    defer f.Close()

    // create new buffer
    buffer := bufio.NewWriter(f)

    for _, line := range lines {
        _, err := buffer.WriteString(line + "\n")
        if err != nil {
           fmt.Println( red("error"), " in buffer.WriteString file=", fileName,"\n\t" , err ) //log.Fatal(err)
        }
    }
    // flush buffered data to the file
    if err := buffer.Flush(); err != nil {
        fmt.Println( red("error"), " in buffer.Flush()cls file=", fileName,"\n\t" , err ) //  log.Fatal(err)
    }
} 
//----------------------------------------
//end of write_and_rewrite.go
//----------------------------------